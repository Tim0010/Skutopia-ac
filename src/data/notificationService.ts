import { supabase } from '@/lib/supabaseClient';

// Define the structure of a Notification
export interface Notification {
    id: string;         // UUID
    user_id: string;     // UUID of the recipient
    created_at: string;  // ISO timestamp string
    message: string;     // The notification text
    is_read: boolean;    // Read status
    link?: string;       // Optional URL to navigate to
    type?: string;       // Optional type (e.g., 'session', 'quiz', 'system')
}

/**
 * Fetches notifications for a specific user.
 * @param userId The ID of the user.
 * @param limit Max number of notifications to fetch (default 20).
 * @param onlyUnread Fetch only unread notifications (default true).
 */
export const fetchNotifications = async (
    userId: string,
    limit: number = 20,
    onlyUnread: boolean = false // Changed default to false to fetch all initially
): Promise<Notification[]> => {
    if (!userId) return [];

    let query = supabase
        .from('notifications')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(limit);

    if (onlyUnread) {
        query = query.eq('is_read', false);
    }

    const { data, error } = await query;

    if (error) {
        console.error("Error fetching notifications:", error);
        throw error;
    }
    return (data as Notification[]) || [];
};

/**
 * Marks specific notifications as read.
 * @param userId The ID of the user owning the notifications.
 * @param notificationIds An array of notification IDs to mark as read.
 */
export const markNotificationsAsRead = async (
    userId: string,
    notificationIds: string[]
): Promise<boolean> => {
    if (!userId || notificationIds.length === 0) return false;

    const { error } = await supabase
        .from('notifications')
        .update({ is_read: true })
        .eq('user_id', userId) // Ensure user can only update their own
        .in('id', notificationIds);

    if (error) {
        console.error("Error marking notifications as read:", error);
        throw error;
    }
    return true;
};

/**
 * Marks ALL notifications as read for a user.
 * @param userId The ID of the user.
 */
export const markAllNotificationsAsRead = async (userId: string): Promise<boolean> => {
     if (!userId) return false;

    const { error } = await supabase
        .from('notifications')
        .update({ is_read: true })
        .eq('user_id', userId)
        .eq('is_read', false); // Only update unread ones

    if (error) {
        console.error("Error marking all notifications as read:", error);
        throw error;
    }
    return true;
};

/**
 * Creates a new notification for a user.
 * NOTE: Requires appropriate RLS policy on the 'notifications' table.
 * @param notificationData Object containing user_id, message, and optional link/type.
 */
export const createNotification = async (
    notificationData: Omit<Notification, 'id' | 'created_at' | 'is_read'> // Exclude fields generated by DB
): Promise<Notification | null> => {
    if (!notificationData.user_id || !notificationData.message) {
        console.error("Cannot create notification: user_id and message are required.");
        return null;
    }

    const { data, error } = await supabase
        .from('notifications')
        .insert({
            ...notificationData,
            is_read: false // Notifications are always unread initially
        })
        .select() // Select the newly created notification
        .single();

    if (error) {
        console.error("Error creating notification:", error);
        throw error;
    }
    return data as Notification | null;
}; 